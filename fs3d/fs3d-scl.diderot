/* ==========================================
## fs3d-scl.diderot: utility for generating synthetic scalar 3D datasets

(This is based on [`fs2d-scl.diderot`](../fs2d) example; some
copy-and-pasting was involved).

This programs generates synthetic scalar 3D data on regular grids, and
the grids have specific location and orientation in world space.
The input arguments here make it easy to sample the same underlying
function on grids with differing orientation, resolution, and shear.

Assuming the directions at https://github.com/Diderot-Language/examples
this program can be compiled with:

	../../vis12/bin/diderotc --exec fs3d-scl.diderot

The `-which` option will determine which function is sampled; look
for `(0 == which)` below to see the function definitions, this
includes 3D functions used to make datasets for
[http://people.cs.uchicago.edu/~glk/pubs/#VIS-2003](some)
[http://people.cs.uchicago.edu/~glk/pubs/#VIS-2009](previous)
[http://people.cs.uchicago.edu/~glk/pubs/#VIS-2014](papers).

This program is unusual in that its printed output needs to be captured
in order to have a NRRD header that records the orientation of the
sampling grid, so using the program involves redirection.  To
get a self-contained parab.nrrd containing a parabola function

	./fs2d-scl -which 3 | unu save -f nrrd -o parab.nrrd
	rm out.nrrd

Note that like in [`fs2d-scl.diderot`](../fs2d), the NRRD header
generated by this program assumes:

1. This program was not compiled with `--double`
2. The program is running on a little-endian machine.

========================================== */
input int sz0 ("# samples on fastest axis") = 32;
input int sz1 ("# samples on medium axis") = 31;
input int sz2 ("# samples on slowest axis") = 30;
input real width ("width of cube region sampled") = 4;
input vec3 axis ("axis (non-normalized) of rotation of sampling grid") = [1,1,1];
input real angle ("angle (in degrees) of rotation of sampling grid") = 0;
input vec3 off ("translation offset from origin-centered grid") = [0,0,0];
input int which ("which function to sample (from 0 to 8)") = 0;
input vec4 parm ("parameters that functions may use") = [0,0,0,0];

real theta = angle*π/180;
// unit-length axis of rotation scaled by sin(theta/2)
vec3 snax = sin(theta/2)*normalize(axis);
// quaternion representing rotation
vec4 qq = [cos(theta/2), snax[0], snax[1], snax[2]];
// rotation matrix. A future version of Diderot may directly support
// matrix/quaternion conversions.
tensor[3,3] rot = [[qq[0]*qq[0] + qq[1]*qq[1] - qq[2]*qq[2] - qq[3]*qq[3],
                    2*(qq[1]*qq[2] - qq[0]*qq[3]),
                    2*(qq[1]*qq[3] + qq[0]*qq[2])],
                   [2*(qq[1]*qq[2] + qq[0]*qq[3]),
                    qq[0]*qq[0] - qq[1]*qq[1] + qq[2]*qq[2] - qq[3]*qq[3],
                    2*(qq[2]*qq[3] - qq[0]*qq[1])],
                   [2*(qq[1]*qq[3] - qq[0]*qq[2]),
                    2*(qq[2]*qq[3] + qq[0]*qq[1]),
                    qq[0]*qq[0] - qq[1]*qq[1] - qq[2]*qq[2] + qq[3]*qq[3]]];
// per axis inter-sample edge vectors
vec3 edge0 = rot•[width/(sz0-1), 0, 0];
vec3 edge1 = rot•[0, width/(sz1-1), 0];
vec3 edge2 = rot•[0, 0, width/(sz2-1)];
// location of first sample point
vec3 orig = -(edge0*(sz0-1) + edge1*(sz1-1) + edge2*(sz2-1))/2 + off;

function real gauss(real xx, real mean, real stdv) {
  real x = xx - mean;
  return exp(-(x*x)/(2*stdv*stdv))/(stdv*sqrt(2*π));
}

function real func(vec3 pos) {
   real x = pos[0];
   real y = pos[1];
   real z = pos[2];
   real ret = 0;
   if (0 == which) {        // 0: x ramp
      ret = x;
   } else if (1 == which) { // 1: y ramp
      ret = y;
   } else if (2 == which) { // 2: z ramp
      ret = z;
   } else if (3 == which) { // 3: parabola
      ret = pos•pos;
   } else if (4 == which) { // 4: scaled parabola
      real sx = 1 + parm[0];
      real sy = 1 + parm[1];
      real sz = 1 + parm[2];
      ret = sx*x^2 + sy*y^2 + sz*z^2;
   } else if (5 == which) { // 5: rounded-cube quartic
      /* Fig 1 of http://people.cs.uchicago.edu/~glk/pubs/#VIS-2003
      used data generated by this function (in a C program); that
      was wholly based on http://dl.acm.org/citation.cfm?id=134082
      This is also http://mathworld.wolfram.com/GoursatsSurface.html
      with (a,b,c) = (0,-1,0), though negated so higher values are
      closer to the origin. The usual isosurface (at isovalue 0)
      fits comfortably inside width 3 */
      ret = x^2 + y^2 + z^2 - x^4 - y^4 - z^4;
   } else if (6 == which) { // 6: Möbius strip
      /* Fig 4 of http://people.cs.uchicago.edu/~glk/pubs/#VIS-2009
      used data generated by this function (in a C program) */
      real dd = parm[2] + 0.85;
      real Rbig = sqrt(x*x + y*y);
      real Rlit = sqrt(z*z + (Rbig-dd)*(Rbig-dd));
      real phi = atan2(Rbig-dd, z) - atan2(x, y)/2;
      real a = Rlit*cos(phi);
      real b = Rlit*sin(phi);
      ret = gauss(a, 0, 0.35+parm[0])*gauss(b, 0, 0.1+parm[1]);
   } else if (7 == which) { // 8: three twisty blades
      /* some methods in http://people.cs.uchicago.edu/~glk/pubs/#VIS-2013
      were debugged with the aid of this datase, though it didn't appear
      in the paper.  The isosurface at isovalue 0.5 fits comfortably
      inside width 2 */
      real R3 = |pos|;
      real mask = lerp(1, 0, -1, erf((R3 - 0.75)*15), 1);
      real R2 = sqrt(x*x + y*y);
      real phi = atan2(y+0.001,x+0.001) + z*1.2;
      real w = pow((1+cos(3*phi))/2, R2*R2*90);
      ret = w*mask;
   } else if (8 == which) { // 7: Cayley cubic surface
      /* see http://mathworld.wolfram.com/CayleyCubic.html
      Fig 2(c) of http://people.cs.uchicago.edu/~glk/pubs/#VIS-2014
      used data generated by this function (in a Diderot program!);
      it assumes width ~= 6. In that paper opacity was limited to
      a sphere of radius 2.7 */
      ret = -(x^2 + y^2 - z*x^2 + z*y^2 + z^2 - 1);
   } else {
      // update "input int which" annotation above as cases are added
      print("HEY no function defined for which = ", which, "\n");
   }
   return ret;
}

strand sample(int idx0, int idx1, int idx2) {
   output real out = 0.0;
   update {
      /* see comment in ../fs2d/fs2d-scl.diderot about the need for these
         conditionals around the print statements */
      if (0 == idx0 && 0 == idx1 && 0 == idx2) {
         print("NRRD0004\n");
         print("# Complete NRRD file format specification at:\n");
         print("# http://teem.sourceforge.net/nrrd/format.html\n");
         /* NOTE: this assumes we haven't been compiled with --double,
            and there isn't currently a way for the program to learn this
            (which in our experience has not been a problem) */
         print("type: float\n");
         print("dimension: 3\n");
         print("sizes: ", sz0, " ", sz1, " ", sz2, "\n");
         print("kinds: space space space\n");
         // NOTE: this assumes machine endianness
         print("endian: little\n");
         print("encoding: raw\n");
         print("space dimension: 3\n");
         print("space directions: (", edge0[0], ",", edge0[1], ",", edge0[2],
                               ") (", edge1[0], ",", edge1[1], ",", edge1[2],
                               ") (", edge2[0], ",", edge2[1], ",", edge2[2], ")\n");
         print("space origin: (", orig[0], ",", orig[1], ",", orig[2], ")\n");
         print("data file: out.nrrd\n");
         print("byte skip: -1\n");
      }
      out = func(orig + idx0*edge0 + idx1*edge1 + idx2*edge2);
      stabilize;
   }
}
initially [ sample(idx0, idx1, idx2)
            | idx2 in 0..(sz2-1),  // slowest axis
              idx1 in 0..(sz1-1),  // medium axis
              idx0 in 0..(sz0-1)]; // fastest axis
