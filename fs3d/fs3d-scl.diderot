/* ==========================================
## fs3d-scl.diderot: utility for generating synthetic scalar 3D datasets

This is based on [`fs2d-scl.diderot`](../fs2d) example (some
copy-and-pasting was involved). Note that like in that, the NRRD header
generated by this program assumes:

1. This program was not compiled with `--double`
2. The program is running on a little-endian machine.

========================================== */
input int sz0 ("# samples on fastest axis") = 32;
input int sz1 ("# samples on medium axis") = 31;
input int sz2 ("# samples on slowest axis") = 30;
input real width ("width of cube region sampled") = 4;
input int which ("which function to sample") = 1;
input vec3 axis ("axis (non-normalized) of rotation of sampling grid") = [1,1,1];
input real angle ("angle (in degrees) of rotation of sampling grid") = 0;
input vec3 off ("translation offset from origin-centered grid") = [0,0,0];

real theta = angle*π/180;
// unit-length axis of rotation scaled by sin(theta/2)
vec3 snax = sin(theta/2)*normalize(axis);
// quaternion representing rotation
vec4 qq = [snax[0], snax[1], snax[2], cos(theta/2)];
// rotation matrix. A future version of Diderot may directly support
// matrix/quaternion conversions.
tensor[3,3] rot = [[qq[0]*qq[0] + qq[1]*qq[1] - qq[2]*qq[2] - qq[3]*qq[3],
                    2*(qq[1]*qq[2] - qq[0]*qq[3]),
                    2*(qq[1]*qq[3] + qq[0]*qq[2])],
                   [2*(qq[1]*qq[2] + qq[0]*qq[3]),
                    qq[0]*qq[0] - qq[1]*qq[1] + qq[2]*qq[2] - qq[3]*qq[3],
                    2*(qq[2]*qq[3] - qq[0]*qq[1])],
                   [2*(qq[1]*qq[3] - qq[0]*qq[2]),
                    2*(qq[2]*qq[3] + qq[0]*qq[1]),
                    qq[0]*qq[0] - qq[1]*qq[1] - qq[2]*qq[2] + qq[3]*qq[3]]];
// per axis inter-sample edge vectors
vec3 edge0 = rot•[width/(sz0-1), 0.0, 0.0];
vec3 edge1 = rot•[0.0, width/(sz1-1), 0.0];
vec3 edge2 = rot•[0.0, 0.0, width/(sz2-1)];
// location of first sample point
vec3 orig = -(edge0*(sz0-1) + edge1*(sz1-1) + edge2*(sz2-1))/2 + off;

function real func(vec3 pos) {
   real x = pos[0];
   real y = pos[1];
   real z = pos[1];
   real ret = 0;
   if (0 == which) {        // 0: x ramp
      ret = x;
   } else if (1 == which) { // 1: y ramp
      ret = y;
   } else if (2 == which) { // 2: z ramp
      ret = z;
   } else if (3 == which) { // 3: parabola
      return pos•pos;
   } else {
      // update "input int which" annotation above as cases are added
      print("HEY no function defined for which = ", which, "\n");
   }
   return ret;
}

strand sample(int idx0, int idx1, int idx2) {
   output real out = 0.0;
   update {
      /* see comment in ../fs2d/fs2d-scl.diderot about the need for these
         conditionals around the print statements */
      if (0 == idx0 && 0 == idx1 && 0 == idx2) {
         print("NRRD0004\n");
         print("# Complete NRRD file format specification at:\n");
         print("# http://teem.sourceforge.net/nrrd/format.html\n");
         /* NOTE: this assumes we haven't been compiled with --double,
            and there isn't currently a way for the program to learn this
            (which in our experience has not been a problem) */
         print("type: float\n");
         print("dimension: 3\n");
         print("sizes: ", sz0, " ", sz1, " ", sz2, "\n");
         print("kinds: space space space\n");
         // NOTE: this assumes machine endianness
         print("endian: little\n");
         print("encoding: raw\n");
         print("space dimension: 3\n");
         print("space directions: (", edge0[0], ",", edge0[1], ",", edge0[2],
                               ") (", edge1[0], ",", edge1[1], ",", edge1[2],
                               ") (", edge2[0], ",", edge2[1], ",", edge2[2], ")\n");
         print("space origin: (", orig[0], ",", orig[1], ",", orig[2], ")\n");
         print("data file: out.nrrd\n");
         print("byte skip: -1\n");
      }
      out = func(orig + idx0*edge0 + idx1*edge1 + idx2*edge2);
      stabilize;
   }
}
initially [ sample(idx0, idx1, idx2)
            | idx2 in 0..(sz2-1),  // slowest axis
              idx1 in 0..(sz1-1),  // medium axis
              idx0 in 0..(sz0-1)]; // fastest axis
