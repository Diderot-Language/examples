/* fs3d-vec.diderot: function sampler, 3D vector synthetic fields

This is based on fs3d-scl.diderot in this same directory, after much
copy-and-pasting.  As with that program, the `-which` option will
determine which function is sampled; look for `(0 == which)` in the
code to see the start of the function definitions.

Assuming the directions at https://github.com/Diderot-Language/examples
this program can be compiled with:

	../../vis12/bin/diderotc --exec fs3d-vec.diderot

This program's printed output needs to be captured to generate
NRRD header with full orientation info. A vector-valued identity
function is sampled via:

	./fs2d-vec -which 0 | unu save -f nrrd -o ident.nrrd
	rm out.nrrd

Note that like in [`fs2d-scl.diderot`](../fs2d), the NRRD header
generated by this program assumes:

1. This program was not compiled with `--double`
2. The program is running on a little-endian machine.
*/

input int sz0 ("# samples on fastest axis") = 52;
input int sz1 ("# samples on medium axis") = 51;
input int sz2 ("# samples on slowest axis") = 50;
input real width ("width of edge of cube region sampled") = 4;
input vec3 axis ("axis (non-normalized) of rotation of sampling grid") = [1,1,1];
input real angle ("angle (in degrees) of rotation of sampling grid") = 0;
input vec3 off ("translation offset, in index space, from origin-centered grid") = [0,0,0];
input int which ("which function to sample (from 0 to 2)") = 0;
input vec3 parm0 ("parameters that functions may use") = [0,0,0];
input vec3 parm1 ("more parameters that functions may use") = [0,0,0];
input vec3 parm2 ("even more parameters that functions may use") = [0,0,0];

real theta = angle*π/180;
// unit-length axis of rotation scaled by sin(theta/2)
vec3 snax = sin(theta/2)*normalize(axis);
// quaternion representing rotation
vec4 qq = [cos(theta/2), snax[0], snax[1], snax[2]];
// create rotation matrix by converstion from quaternion
// (which aren't currently natively supported in Diderot)
tensor[3,3] rot = [[qq[0]*qq[0] + qq[1]*qq[1] - qq[2]*qq[2] - qq[3]*qq[3],
                    2*(qq[1]*qq[2] - qq[0]*qq[3]),
                    2*(qq[1]*qq[3] + qq[0]*qq[2])],
                   [2*(qq[1]*qq[2] + qq[0]*qq[3]),
                    qq[0]*qq[0] - qq[1]*qq[1] + qq[2]*qq[2] - qq[3]*qq[3],
                    2*(qq[2]*qq[3] - qq[0]*qq[1])],
                   [2*(qq[1]*qq[3] - qq[0]*qq[2]),
                    2*(qq[2]*qq[3] + qq[0]*qq[1]),
                    qq[0]*qq[0] - qq[1]*qq[1] - qq[2]*qq[2] + qq[3]*qq[3]]];
// per axis inter-sample edge vectors
real space0 = width/(sz0-1);
real space1 = width/(sz1-1);
real space2 = width/(sz2-1);
vec3 edge0 = rot•[space0, 0, 0];
vec3 edge1 = rot•[0, space1, 0];
vec3 edge2 = rot•[0, 0, space2];
// offset in world space
vec3 offws = [off[0]*space0, off[1]*space1, off[2]*space2];
// location of first sample point
vec3 orig = -(edge0*(sz0-1) + edge1*(sz1-1) + edge2*(sz2-1))/2 + offws;

function vec3 func(vec3 pos) {
   real x = pos[0];
   real y = pos[1];
   real z = pos[2];
   vec3 ret = [0,0,0];
   if (0 == which) {        // 0: identity
      ret = [x,y,z];
   } else if (1 == which) { // 2: with Jacobian = [parm0, parm1, parm2]
      tensor[3,3] jac = [parm0, parm1, parm2];
      ret = jac•pos;
   } else if (2 == which) { // 1: something with predictable derivatives
      // Note: this is used by another example ../tensor/tensor.diderot
      ret = [x,2*y,4*z] + x*[0.4,0.2,0.1] + x*x*[0,0.4,0] + y*z*[0,0,1];
   } else {
      // update "input int which" annotation above as cases are added
      print("Sorry, no function defined for which = ", which, "\n");
   }
   return ret;
}

strand sample(int idx0, int idx1, int idx2) {
   output vec3 out = [0,0,0];
   update {
      /* see comment in ../fs2d/fs2d-scl.diderot about the need for these
         conditionals around the print statements */
      if (0 == idx0 && 0 == idx1 && 0 == idx2) {
         print("NRRD0004\n");
         print("# Complete NRRD file format specification at:\n");
         print("# http://teem.sourceforge.net/nrrd/format.html\n");
         /* NOTE: this assumes we haven't been compiled with --double,
            and there isn't currently a way for the program to learn this
            (which in our experience has not been a problem) */
         print("type: float\n");
         print("dimension: 4\n");
         print("sizes: 3 ", sz0, " ", sz1, " ", sz2, "\n");
         print("kinds: 3-vector space space space\n");
         print("centers: none cell cell cell\n");
         // NOTE: this assumes machine endianness
         print("endian: little\n");
         print("encoding: raw\n");
         print("space dimension: 3\n");
         print("space directions: none (", edge0[0], ",", edge0[1], ",", edge0[2],
                               ") (", edge1[0], ",", edge1[1], ",", edge1[2],
                               ") (", edge2[0], ",", edge2[1], ",", edge2[2], ")\n");
         print("space origin: (", orig[0], ",", orig[1], ",", orig[2], ")\n");
         print("data file: out.nrrd\n");
         print("byte skip: -1\n");
      }
      out = func(orig + idx0*edge0 + idx1*edge1 + idx2*edge2);
      stabilize;
   }
}
initially [ sample(idx0, idx1, idx2)
            | idx2 in 0..(sz2-1),  // slowest axis
              idx1 in 0..(sz1-1),  // medium axis
              idx0 in 0..(sz0-1)]; // fastest axis
