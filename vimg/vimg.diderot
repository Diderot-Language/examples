/* ==========================================
## vimg.diderot: 2D image sampler/viewer

This program needs a dataset to render, and a colormap, for example:

	ln -s ../data/sscand.nrrd img.nrrd
	ln -s ../cmap/spiralch.nrrd cmap.nrrd

Then compile this program; assuming the directions at
https://github.com/Diderot-Language/examples you can:

	../../vis12/bin/diderotc --exec vimg.diderot

If the needed `img.nrrd` file is missing, the error message looks something like:

	uncaught exception Fail [Fail: Nrrd file "img.nrrd" does not exist]
	  raised at common/phase-timer.sml:78.50-78.52
	  raised at common/phase-timer.sml:78.50-78.52
	  raised at nrrd/nrrd-info.sml:146.15-146.74

in which case you should run the `ln -s` command above, or link `img.nrrd`
to some other 2D scalar nrrd file to view.  The same applies to the need
for `cmap.nrrd` to link to a colormap.

The `-which` option will determine which function is sampled; look
for `(0 == which)` below to see the start of the function definitions.
Assuming the symbolic links given above (of `img.nrrd`
and `cmap.nrrd` to `../data/sscand.nrrd` and `../cmap/spiralch.nrrd`
respectively), some examples usages are:
* `./vimg -cent 290 414 -fov 45 -which 0`
* `./vimg -cent 290 414 -fov 45 -which 1`
* `./vimg -cent 290 414 -fov 45 -which 2`
* `./vimg -cent 290 414 -fov 45 -which 3 -cmin -500 -cmax 1900 -iso 1210 -th 18`
* `./vimg -cent 290 414 -fov 45 -which 4 -cmin -500 -cmax 1900 -iso 1210 -th 0.18`

In all cases, one can `unu quantize -b 8 -i rgb.nrrd -o rgb.png` to create
an 8-bit image version of the output.  The `-which 3` and `-which 4` commands
show an important comparison, by demonstrating how knowing the gradient permits
drawing of equal-thickness isocontours (according to the first-order Taylor
expansion).

Viewing `../data/sscand.nrrd` with the parameters above gives a roughly
100km view of the area around Geilo, Norway, site of the
[Winter School](http://www.sintef.no/projectweb/geilowinterschool/2016-scientific-visualization/)
for which this program was originally created.
========================================== */

input image(2)[] img ("2D image dataset to view") = image("img.nrrd");
input image(1)[3] cmimg ("colormap to use") = image("cmap.nrrd");
input vec2 cent ("center of viewing window") = [0,0];
input real fov ("height of viewing window") = 2;
input int sx ("# of horizontal samples in viewing window") = 640;
input int sy ("# of vertical samples in viewing window") = 480;
input real angle ("orientation (in counter-clockwise degrees) of viewing window") = 0;
input int which ("what to show about the image, currently from 0 to 4") = 0;
input real iso ("value at which to show approximate isocontour") = 0;
input real th ("thickness of isocontour") = 1;
input real cmin ("value to use at min end of colormap") = 0;
input real cmax ("value to use at max end of colormap") = 1;

// the colormap can always use tent; it is not differentiated
field#0(1)[3] cmap = tent ⊛ cmimg;

// field to sample and view
// C1 kernels include c1tent, ctmr, bspln3, c4hexic
field#1(2)[] F = c4hexic ⊛ img;

// compute the image-to-world transform based on specification
// of the viewing window
real wdth = fov*sx/sy;
real phi = angle*π/180;
tensor[2,2] rot = [[cos(phi),sin(phi)],[-sin(phi),cos(phi)]];
vec2 spc = [wdth/(sx-1), fov/(sy-1)];
vec2 dir0 = rot•[spc[0], 0];
vec2 dir1 = rot•[0, spc[1]];
vec2 orig = cent - (dir0*(sx-1) + dir1*(sy-1))/2;

// A function that is 1 at 0, and goes down linearly to 0 according to
// thickness parameter th. Note that if a function is a simple expression like
// this it can be defined with a single `=`, with no need for a `return`
// inside a sequence of statements. You might want to call this function
// "tent" but that name is already taken by a kernel.
function real bump(real z) = max(0, 1 - |z|/th);

strand sample(int ui, int vi) {
   // The output type for a Diderot program is fixed at compile-time,
   // regardless of input variable values or execution outcomes. So
   // this program sometimes saves what is really just grayscale
   // information in an RGB color image.
   output vec3 rgb = [0,0,0];
   real y = 0;
   update {
      vec2 x = orig + ui*dir0 + vi*dir1;
      if (inside(x, F)) {
         if (0 == which) {
            // the image value itself
            y = F(x);
            rgb = [y,y,y];
         } else if (1 == which) {
            // the gradient magnitude
            y = |∇F(x)|;
            rgb = [y,y,y];
         } else if (2 == which) {
            // the gradient vector, saved in
            // first two components of output
            vec2 gg = ∇F(x);
            rgb = [gg[0],gg[1],0];
         } else if (3 == which) {
            // colormapped, with simple value-based isocontour
            // Note that there isn't (curently) a way to learn
            // within the language what the domain of colormap
            // (or of any field) is, so that we want to scale the
            // function range to [0,1] here reflects either prior
            // knowledge or an assumption about the orientation
            // meta-data in whatever cmap.nrrd links to
            // HEY: use clerp() when available
            rgb = cmap(clamp(0,1,lerp(0,1,cmin,F(x),cmax)));
            rgb *= 1 - bump(F(x) - iso);
         } else if (4 == which) {
            // colormapped, with Newton-based isocontour
            // HEY: use clerp() when available
            rgb = cmap(clamp(0,1,lerp(0,1,cmin,F(x),cmax)));
            rgb *= 1 - bump((F(x) - iso)/|∇F(x)|);
         } else {
            // update "input int which" annotation above as cases are added
            print("Sorry, no function defined for which = ", which, "\n");
         }
      }
      stabilize;
   }
}

initially [ sample(ui, vi) | vi in 0..(sy-1),
                             ui in 0..(sx-1) ];
