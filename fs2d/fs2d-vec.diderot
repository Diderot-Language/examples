#version 1.0
/* fs2d-vec.diderot: function sampler, 2D vector synthetic fields

This is based on fs2d-scl.diderot in this same directory, after much
copy-and-pasting (with fewer comments).  As with that program, the
`-which` option will determine which function is sampled; look for
`("x" == which)` in the code to see the start of the function definitions.

This program's printed output needs to be captured to generate
NRRD header with full orientation info. A vector-valued identity
function is sampled via:

	./fs2d-vec -which ident | unu save -f nrrd -o ident.nrrd
	rm out.nrrd

Note that like in [`fs2d-scl.diderot`](../fs2d), the NRRD header
generated by this program assumes:

1. This program was not compiled with `--double`
2. The program is running on a little-endian machine.
*/

input string which ("which function to sample, currently one of: ");                 

input int size0 ("# samples on faster axis") = 101;
input int size1 ("# samples on slower axis") = 100;
input real width ("approx width of world-space region sampled") = 1;
input vec2 off ("translation offset from origin-centered grid") = [0,0];
input real shear ("amount of shear in sampling grid") = 0;
input real angle ("orientation (in degrees) of faster axis") = 0;
input real wangle ("orientation (in degrees) of world coords") = 0;
input vec4 parm ("parameters that functions may use") = [0,0,0,0];

real phi = angle*π/180;
tensor[2,2] rot = [[cos(phi),-sin(phi)],[sin(phi),cos(phi)]];
real wphi = wangle*π/180;
tensor[2,2] wrot = [[cos(wphi),-sin(wphi)],[sin(wphi),cos(wphi)]];
vec2 spc = [width/(size0-1), width/(size1-1)];
vec2 edge0 = rot•[spc[0], 0];
vec2 edge1 = rot•[0, spc[1]] + shear*spc[1]*normalize(edge0);
vec2 orig = -(edge0*(size0-1) + edge1*(size1-1))/2 + off;

// The function to evaluate at each grid point.
function vec2 func(vec2 pos0) {
   vec2 pos = wrot•pos0;
   vec2 ret = [0,0];
   /* parenthesized numbers in comments are the integers
      previously used to identify the case */
   if ("ident" == which) {    // the identity field
      ret = pos;
   } else if ("jac" == which) { // with Jacobian=parm[], reshaped to 2x2
      tensor[2,2] jac = [[parm[0],parm[1]],[parm[2],parm[3]]];
      ret = jac•pos;
   } else {
      // update "input string which" annotation above as cases are added
      print("Sorry, no function defined for which = ", which, "\n");
   }
   return ret;
}

strand sample(int idx0, int idx1) {
   output vec2 out=[0,0];
   update {
      if (0 == idx0 && 0 == idx1) {
         print("NRRD0004\n");
         print("# Complete NRRD file format specification at:\n");
         print("# http://teem.sourceforge.net/nrrd/format.html\n");
         // NOTE: this assumes we haven't been compiled with --double
         print("type: float\n");
         print("dimension: 3\n");
         print("sizes: 2 ", size0, " ", size1, "\n");
         print("kinds: 2-vector space space\n");
         print("centers: none cell cell\n");
         // NOTE: this assumes machine endianness
         print("endian: little\n");
         print("encoding: raw\n");
         print("space dimension: 2\n");
         print("space directions: none (", edge0[0], ",", edge0[1],
                               ") (", edge1[0], ",", edge1[1], ")\n");
         print("space origin: (", orig[0], ",", orig[1], ")\n");
         // NOTE: this assumes output filename is not explicitly set
         print("data file: out.nrrd\n");
         print("byte skip: -1\n");
      }
      out = func(orig + idx0*edge0 + idx1*edge1);
      stabilize;
   }
}

initially [ sample(idx0, idx1)
           | idx1 in 0..(size1-1),   // SLOWER axis
             idx0 in 0..(size0-1) ]; // FASTER axis
