/* ==========================================
## iso2d.diderot: 2D isocontour sampling by independent (non-interacting) particles

First make a little dataset, using ../fs2d/fs2d-scl:

	../fs2d/fs2d-scl -size0 60 -size1 60 -which 3 -width 8 2>&1 | unu save -f nrrd -o cubic.nrrd

Then compile this program; assuming the directions at
https://github.com/Diderot-Language/examples you can:

	../../vis12/bin/diderotc --exec iso2d.diderot

You should try `iso2d --help` to see the available input variables.
Note that if a Diderot program refers to an image file, that image
file needs to exist at compile time (so that the compiler can generate
instructions specific to the data type and the image
orientation). Hence the need to create cubic.nrrd before running
diderotc.  If a needed .nrrd file is missing, the error message looks
like:

	uncaught exception Fail [Fail: Nrrd file "cubic.nrrd" does not exist]
	  raised at common/phase-timer.sml:78.50-78.52
	  raised at common/phase-timer.sml:78.50-78.52
	  raised at nrrd/nrrd-info.sml:146.15-146.74


To now run the isocontour sampling (starting with a 100x100 grid of points)

	./iso2d -cmin -4 -4 -cmax 4 4 -isoval -0.5 -size 100

which saves the output positions in pos.nrrd as a list of 2-vectors, which
can be seen by running `unu head pos.nrrd`. You can convert this to a
text file with:

	unu save -f text -i pos.nrrd -o pos.txt

In any case, Diderot doesn't itself supply a way of visualizing this
point set; some other graphics or plotting program is needed.  A really
quick-and-dirty way of showing the points is as a joint histogram
of their X and Y coordinates:

	unu jhisto -i pos.nrrd -b 500 500 -min -4 -4 -max 4 4 -t float | unu 2op gt - 0 | unu quantize -b 8 -o pos.png

Even though you had to supply the input image at compile-time, you can
supply a different image at run-time, if the image is noted as an
"input" (as below), and provided that the new image exactly matches
the type and shape of the compile-time image.  We can add some noise
to the dataset:

	unu 2op nrand cubic.nrrd 0.4 -s 42 -o noisy.nrrd

and then re-run the isocontouring and display on the new data.

	./iso2d -cmin -4 -4 -cmax 4 4 -isoval -0.5 -size 100 -img noisy.nrrd -o pos2.nrrd
	unu jhisto -i pos2.nrrd -b 500 500 -min -4 -4 -max 4 4 -t float | unu 2op gt - 0 | unu quantize -b 8 -o pos2.png

Things to try (to see their effect on the output positions, both the
number of outputs and their location):
* increasing or decreasing `stepsMax`
* increasing or decreasing `epsilon`
* increasing or decreasing `size`; if it goes too low then the program will not have any output
========================================== */

input real isoval = 0;        // the isovalue
input int stepsMax = 10;      // max # steps allowed to converge
input real epsilon = 0.00001; // convergence threshold
input image(2)[] img = image("cubic.nrrd"); // data to isocontour

// way of specifying the grid on which sampling is done
input vec2 cmin = [-1,-1]; // # lower corner of sampling grid
input vec2 cmax = [1,1];   // # upper corner of sampling grid
input int size = 30;       // # samples on both axes

// field is defined so isocontour of interest is at zero levelset
field#1(2)[] F = c4hexic ⊛ img - isoval;


/*
The ID argument is not actually used, but it is included here as an
example of a way of identifying strands that can be useful for
debugging.
*/
strand iso(int ID, vec2 pos0) {
   output vec2 pos = pos0;
   int steps = 0;
   update {
      // Stop if no longer inside, or have taken too many steps.
      if (!inside(pos, F) || steps > stepsMax) {
         die;
      }

      // Subsequent expressions are undefined if |∇F| is zero
      if (|∇F(pos)| == 0.0) {
         die;
      }

      // The Newton-Raphson step
      vec2 delta = -normalize(∇F(pos)) * F(pos)/|∇F(pos)|;
      pos += delta;

      // We've converged if delta is small enough
      if (|delta| < epsilon) {
         stabilize;
      }
      steps += 1;
   }
}

/*
** This generates a node-centered sampling of the region;
** a cell-centered sampling would be created with:
                [lerp(cmin[0], cmax[0], -0.5, idx0, size-0.5),
                 lerp(cmin[1], cmax[1], -0.5, idx1, size-0.5)])
*/
initially { iso(idx0 + size*idx1,
                [lerp(cmin[0], cmax[0], 0, idx0, size-1),
                 lerp(cmin[1], cmax[1], 0, idx1, size-1)])
           | idx1 in 0..(size-1),   // SLOWER axis
             idx0 in 0..(size-1) }; // FASTER axis
