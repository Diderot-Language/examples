/* ==========================================
This program finds square roots of numval reals between minval and maxval
using Heron's method (aka the Babylonion method)
https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method

Assuming the directions at https://github.com/Diderot-Language/examples
this program can be compiled and run with:

	../../vis12/bin/diderotc --exec heron.diderot
	./heron

The output stores four numbers for each value processed:
<ol start="0">
<li> the value whose square root was found
<li> the computed square root
<li> the number of iterations taken to compute it
<li> the error, relative to Diderot's sqrt() function
</ol>
To see the values (one set of 4 numbers per line):

	unu save -f text -i vrie.nrrd

The command-line executables produced by Diderot have hest-generated
usage infomation; try:

	./heron --help

to see how to set the input values and output filename stem.  Note
that input variables can document their purpose with ("...")
annotations that are included in the --help usage information.

Try experimenting with different values for eps; if it is set too low
the algorithm may not converge.  Compiling with:

	../../vis12/bin/diderotc --double --exec heron.diderot

makes "reals" into doubles, instead of the default single-precision
floats, which permits higher-accuracy results.
========================================== */

input real minval ("min value to find root of") = 1;
input real maxval ("max value to find root of") = 100;
input int numval ("how many values to compute") = 100;
input real eps ("relative error convergence test") = 0.000001;

// One strand per value. The name of the strand need
// not be related to the name of the source file.
strand sqroot (real val) {
   real root = val; // initialize with sqrt(N) = N
   int iter = 0;    // count iterations required
   // the output: value, root, iters, error. In Diderot
   // all variables must be initialized at declaration.
   output vec4 vrie = [0,0,0,0];

   // each update does one iteration of Heron's method
   update {
      if (val <= 0) {
         // no work to be done
         stabilize;
      }
      iter += 1;
      root = (root + val/root) / 2.0;
      if (|root^2 - val|/val < eps) {
         stabilize;
      }
   }
   // The stabilize method is called upon strand stabilization;
   // you can use this to do some post-processing on whatever
   // computation has finished, prior to saving the output
   stabilize {
      vrie = [val, root, iter, sqrt(val)-root];
   }
}

/*
** Initialize strands with value to take the square root of; with this
** 5-argument lerp, the output ranges from minval to maxval as ii ranges
** from 1 to numval. The "initially { }" creates a collection of
** strands (as opposed to a grid).
*/
initially { sqroot(lerp(minval, maxval, 1, ii, numval)) | ii in 1 .. numval };
