/* ==========================================
## plot1d.diderot: plot 1D scalar field (univariate function)

example usage:

	echo 1 | unu reshape -s 1 | unu dnorm -o - | unu pad -min -10 -max M+10 -b pad -v 0 -o data.nrrd
	./plot1d -xsize 800 -ysize 400 -xmm -4 4 -ymm -0.3 1.1 -pthick 5 -athick 3 -twidth 25
	unu quantize -b 8 -i rgb.nrrd -o plot.png
	open plot.png

This is the place to try different kernels:
tent, (c1tent, c2tent moot with continuity assertions)
ctmr, (c2ctmr moot with continuity assertions)
bspln3
bspln5
c4hexic
========================================== */

input image(1)[] img = image("data.nrrd"); // data to plot

// way of specifying the grid on which sampling is done
input vec2 xmm = [-4,4];    // [min,max] along horizontal
input vec2 ymm = [-0.9,1.1];  // [min,max] along vertical
input int xsize = 800;      // # samples along horizontal
input int ysize = 400;      // # samples along vertical

// size of things
input real athick = 4;  // axis and tickmark thickness, in pixels
input real pthick = 7;  // plot thickness, in pixels
input real twidth = 20; // tickmark width, in pixels
// colors of things
input vec3 plotrgb = [0.4,0,0];
input vec3 axisrgb = [0.8,0.8,0.9];
input vec3 tickrgb = [0.7,0.7,0.8];

// function has to be at least C^1 (slope used for graphing)
field#1(1)[] F = c4hexic ⊛ img;

// aspect ratio of pixels in world-space
real asp = ((ysize-1)/(ymm[1]-ymm[0])) / ((xsize-1)/(xmm[1]-xmm[0]));

// plot is a trapezoid, centered at origin, at height 1 for width th,
// with sides going down to zero over unit interval on either side
function real tzoid (real d, real th) {
   real ret = 0;
   if (|d| < th/2) {
      ret = 1;
   } else {
      ret = max(0, lerp(1, 0, th/2, |d|, th/2 + 1)); // HEY use clerp
   }
   return ret;
}

// indicates partial membership in a line of given thickness,
// at distance d away from the line
function real aline(real d) = tzoid(d, athick);
function real pline(real d) = tzoid(d, pthick);

// indicates partial membership in 0-centered tickmark,
// at distance d from axis
function real tick(real d) = tzoid(d, twidth);

// rounds v to nearest integer
function real round(real v) = (v+0.5 - fmod(v+0.5, 1)
                               if (v > 0) else
                               -(-v+0.5 - fmod(-v+0.5, 1)));

/*
** For converting between index and world, along X and Y. Note
** that the function inverse is obtained by switching the input
** interval (args 3 and 5) with the output interval (args 1 and 2).
*/
function real xw2i(real w) = lerp(-0.5, xsize-0.5, xmm[0], w, xmm[1]);
function real xi2w(real i) = lerp(xmm[0], xmm[1], -0.5, i, xsize-0.5);
function real yw2i(real w) = lerp(-0.5, ysize-0.5, ymm[1], w, ymm[0]);
function real yi2w(real i) = lerp(ymm[1], ymm[0], -0.5, i, ysize-0.5);

strand plot(int xi, int yi) {
   output vec3 rgb = [1,1,1];
   update {
      // image is cell-centered sampling of world-space
      // [xmm[0],xmm[1]] × [ymm[0],ymm[1]]

      // convert (0,0) from world to index, and draw axes
      real y0i = yw2i(0);
      real x0i = xw2i(0);
      rgb = lerp(rgb, axisrgb, aline(y0i - yi));
      rgb = lerp(rgb, axisrgb, aline(x0i - xi));

      // tick marks at integers
      rgb = lerp(rgb, tickrgb, tick(y0i - yi)*aline(xw2i(round(xi2w(xi))) - xi));
      rgb = lerp(rgb, tickrgb, tick(x0i - xi)*aline(yw2i(round(yi2w(yi))) - yi));

      // convert strand X position from index to world
      real xw = xi2w(xi);
      if (inside(xw, F)) {
         // convert F(x) to index-space Y
         real fxi = yw2i(F(xw));
         real mm = asp*∇F(xw);
         //real mm = asp*(F(xw+0.001) - F(xw-0.001))/0.002; // hack to get derivative
         rgb = lerp(rgb, plotrgb, pline((yi - fxi)/sqrt(1 + mm^2)));
      }
      stabilize;
   }
}

initially [ plot(xi, yi)
           | yi in 0..(ysize-1),   // SLOWER axis
             xi in 0..(xsize-1) ]; // FASTER axis
