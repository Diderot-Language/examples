Half-toning via interacting repulsive particles

This example is based on the [`sphere.diderot`](../sphere) example, which in
turn is based on the [`circle.diderot`](../circle) example; both of these
should be read and understood first.  While in those cases a surface (circle
or sphere) is sampled uniformly, in this case the flat surface of an image is
sampled non-uniformly, according to the image intensity.  This creates a
result similar to the [Electrostatic
Halftoning](http://www.mia.uni-saarland.de/Research/Electrostatic_Halftoning/index.shtml)
method of Schmaltz et al. The very regular hexagonal grid patterns that this
program generates by energy minimization in uniform areas may be sub-optimal
for artistic or signal-processing purposes; this program lacks the jittering
that better haltoning methods add to avoid this.  The regular sampling
generated by this program could help subsequent meshing.

The standard test for this kind of program is a linear ramp, which is
available via:

	../fs2d/fs2d-scl -which 0 -width 2 -size0 401 -size1 401 |
	unu crop -min 0 100 -max M M-100 |
	unu affine -1 - 1 0 1 |
	unu pad -min -2 -2 -max M+2 M+2 -o img.nrrd

The domain of this `img.nrrd` is [-1,1] along X, and [-0.5,0.5] along Y, and
which varies from 0 at X=-1 to 1 at X=1. Two extra samples are added at
the boundaries to ensure that even at the boundary, the `inside()` test
passes. With this proxy image in place, we can compile:

	diderotc --snapshot --exec halftone.diderot

We use snapshots to monitor the progress of computation.  To make `NN` initial
positions with random number seen `RNG` that fit within the ramp image domain:

	NN=100
	RNG=5
	echo 0 0 | unu pad -min 0 0 -max M $[NN-1] | unu 1op rand -s $RNG | unu affine 0 - 1 -1 1 -o vec2.nrrd
	echo 1 0.5 | unu 2op x vec2.nrrd - -o vec2.nrrd

Then to run with snapshots saved every iteration (`-s 1`), but limiting the program
to 800 iterations (`-l 800`), as well as cleaning results from previous run:

	rm -f pos-????.{png,nrrd} pos.nrrd
	./halftone -s 2 -l 800 -radmm 0.03 1 -eps 0.0001 -pcp 2

Running with this large value (0.03) of minimum radius (considering the image domain)
is good for giving a visual impression of how the particle system populates the
domain. This does some `unu` hacking to make images of the evolving system, which
are then turned into an animated `ramp.gif` (compare to `[ramp-ref.gif](ramp-ref.gif)).

	SZ=200
	OV=2
	export NRRD_STATE_VERBOSE_IO=0
	for PIIN in pos-????.nrrd; do
	   IIN=${PIIN#*-}
	   II=${IIN%.*}
	   echo "post-processing $PIIN to pos-$II.png ... "
	   unu jhisto -i $PIIN -min -1 -0.5 -max 1 0.5 -b $[OV*SZ*2] $[SZ*OV] |
	     unu resample -s /$OV /$OV -k bspln5 -t float |
	     unu quantize -b 8 -min 0 -max $(echo "0.15 / ($OV * $OV)" | bc -l) -o pos-$II.png
	done
	convert -delay 6 pos-*.png ramp.gif

On the other hand, to quantitatively check that the particle density is as it should be,
we run with many more particles (which can take a few minutes to finish), and make a
histogram of the X positions to ensure it approaches a linear ramp:

	rm -f {hp,pos}-????.{png,nrrd} pos.nrrd
	./halftone -s 10 -l 800 -radmm 0.004 1 -eps 0.00004 -pcp 2
	SZ=200
	OV=2
	export NRRD_STATE_VERBOSE_IO=0
	for PIIN in pos-????.nrrd; do
	   IIN=${PIIN#*-}
	   II=${IIN%.*}
	   echo "post-processing $PIIN to pos-$II.png ... "
	   unu jhisto -i $PIIN -min -1 -0.5 -max 1 0.5 -b $[OV*SZ*2] $[SZ*OV] |
	     unu resample -s /$OV /$OV -k bspln5 -t float |
	     unu quantize -b 8 -min 0 -max $(echo "1.8 / ($OV * $OV)" | bc -l) -o pos-$II.png
	   unu slice -i $PIIN -a 0 -p 0 |
	     unu histo -min -1 -max 1 -b $[SZ/3] |
	     unu dhisto -h $[SZ/3] -nolog |
	     unu resample -s $[SZ*2] = -k box |
	     unu join -i - pos-$II.png -a 1 -o hp-$II.png
	done
	convert -delay 6 hp-*.png hp.gif

The resulting `hp.gif` (compare to `[hp-ref.gif](hp-ref.gif)) shows the
expected convergence to a linear variation in particle density.

