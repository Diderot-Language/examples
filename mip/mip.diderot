/* ==========================================
## mip.diderot: basic maximum intensity projection (MIP) volume rendering

(docs in progress)

This has code that is re-used verbatim in other examples, both for
setting up the ray-casting geometry given the camera specification, as
well as for sampling along rays. This may later become a target for evolving
Diderot to support libraries that contain common functionality.
========================================== */

input image(3)[] vol ("volume dataset to MIP") = image("vol.nrrd");
/* Look-from and look-at are points, but up is a vector;
   all are stored in vec3s.  Diderot has not adopted this
   mathematical vector-vs-point distinction into its type system */
input vec3 camEye ("camera look-from point") = [6, 9, 2];
input vec3 camAt ("camera look-at point") = [0, 0, 0];
input vec3 camUp ("camera pseudo-up vector") = [0, 0, 1];
input real camNear ("relative to look-at point, distance to near clipping plane (where rays start from)") = -3;
input real camFar ("relative to look-at point, distance to far clipping plane") = 3;
input real camFOV ("field-of-view angle subtended vertically by view plane") = 15;
input bool camOrtho ("whether to use orthographic, instead of perspective, projection") = false;
input int iresU ("# samples on horizontal axis of image") = 640;
input int iresV ("# samples on vertical axis of image") = 480;
input real rayStep ("inter-sample step along view direction") = 0.1;
input real out0 ("value at which to initilize output max accumulator; using -inf ensures that output will stay -inf if ray misses volume entirely") = -∞;

/* convolve volume data with kernel. */
field#0(3)[] F = tent ⊛ vol;

// (boilerplate) computing ray parameters and view-space basis
vec3 camN = normalize(camAt - camEye);  // N: away from eye
vec3 camU = normalize(camN × camUp);    // U: right
vec3 camV = camN × camU;                // V: down
real camDist = |camAt - camEye|;
real camVmax = tan(camFOV*π/360)*camDist;
real camUmax = camVmax*iresU/iresV;
real camNearVsp = camNear + camDist; // near clip, view space
real camFarVsp = camFar + camDist;   // far clip, view space

// how to compute MIP of ray through (rayU,rayV) on view plane
strand raycast(real rayU, real rayV) {
   output real out = out0;
   real rayN = camNearVsp;
   // offset from view-plane center to where ray hits it
   vec3 UV = rayU*camU + rayV*camV;
   // where ray starts (ray position at N=0)
   vec3 rayOrig = camEye + (UV if camOrtho else [0,0,0]);
   // the vector to parameterize position along ray for this pixel
   vec3 rayVec = camN + ([0,0,0] if camOrtho else UV/camDist);

   update { // how to compute one sample of a MIP
      vec3 pos = rayOrig + rayN*rayVec;  // pos = ray sample position
      if (inside(pos,F)) {  // can only query field inside its domain
         out = max(out, F(pos));  // update max value seen so far
      }
      if (rayN > camFarVsp) {  // ray hit the far clipping plane
         stabilize;
      }
      rayN += rayStep;  // increment ray position
   }
}

/* this creates a cell-centered sampling of the view plane */
initially [ raycast(lerp(-camUmax, camUmax, -0.5, ui, iresU-0.5),
                    lerp(-camVmax, camVmax, -0.5, vi, iresV-0.5))
            | vi in 0..iresV-1, ui in 0..iresU-1 ];
