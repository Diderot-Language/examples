/* ==========================================
## isopt2d.diderot: 2D isocontour sampling by interacting particles

... under construction ...

========================================== */

input image(2)[] img ("data to isocontour") = image("img.nrrd");
input real isoval ("isovalue of isosurface to sample") = 0;

input int stepsMax ("max # steps allowed for initial convergence, or 0 to make unlimited") = 10;
input real travelMax ("max amount of travel allowed for initial convergence, or 0 to make unlimited") = 0.1;
input real epsilon ("convergence threshold") = 0.00001;

input real radius = 0.01;    // particle interaction radius

// way of specifying the grid on which initial sampling is done
input vec2 cent ("center of initial sampling grid") = [0,0];
input real fov ("height (on slow axis) of sampling grid") = 2;
input int sz0 ("# of horizontal (fast axis) samples in grid") = 40;
input int sz1 ("# of vertical (slow axis) samples in grid") = 40;
input real angle ("orientation (in counter-clockwise degrees) of grid") = 0;

// compute the index-to-world transform for the initial sampling grid
real wdth = fov*sz0/sz1;
real th = angle*π/180;
tensor[2,2] rot = [[cos(th),sin(th)],[-sin(th),cos(th)]];
vec2 spc = [wdth/(sz0-1), fov/(sz1-1)];
vec2 dir0 = rot•[spc[0], 0];
vec2 dir1 = rot•[0, spc[1]];
vec2 orig = cent - (dir0*(sz0-1) + dir1*(sz1-1))/2;

// field is defined so that isocontour of interest is the zero levelset
field#1(2)[] F = c4hexic ⊛ img - isoval;

// inter-particle energy, and its derivative
function real  phi(real x)  =   (1 - |x|)^4 if |x| < 1 else 0.0;
function real phi'(real x) = -4*(1 - |x|)^3 if |x| < 1 else 0.0;
//function real  phi(real x)  =  (1/|x|)*(1-|x|)^3 if |x| < 1 else 0.0;
//function real phi'(real x) = 3 - 1/(x^2) - 2*|x| if |x| < 1 else 0.0;

int iter = 0;
int iterLimit = 100;

/*
The ID argument is not actually used, but it is included here as an
example of a way of identifying strands that can be useful for
debugging.
*/
strand particle(int ID, vec2 pos0) { // vec2 is a synonym for tensor[2]
   output vec2 pos = pos0;
   int steps = 0;
   real travel = 0;
   bool foundIso = false;
   real tt = radius/2;    // line search step size
   real energyReport=0;
   real energyLast=0;
   update {
      if (!foundIso) {
         // various reasons to call it quits
         if (!inside(pos, F)                          // no longer inside
             || (stepsMax > 0 && steps > stepsMax)    // too many steps
             || (travelMax > 0 && travel > travelMax) // too much travel
             || |∇F(pos)| == 0) {                     // can't compute step
            die;
         }
         // The Newton-Raphson step
         vec2 dpos = -normalize(∇F(pos)) * F(pos)/|∇F(pos)|;
         travel += |dpos|;
         pos += dpos;
         // We've converged if dpos is small enough
         if (|dpos| < epsilon) {
            foundIso = true;
         }
         steps += 1;
      } else {
         vec2 force=[0,0];
         energyLast=0;
         foreach (particle P in sphere(radius)) {
            vec2 r_ij = (pos - P.pos)/radius;
            energyLast += phi(|r_ij|);
            force -= normalize(r_ij)*phi'(|r_ij|)/radius;
         }
         energyReport = energyLast;
         // project force onto tangent plane
         force -= normalize(∇F(pos))⊗normalize(∇F(pos))•force;
         if (|force| > 0) { // take gradient descent step
            vec2 dpos = tt*normalize(force);
            vec2 posLast = pos;
            pos += dpos;
            // take Newton-Raphson step back to surface
            if (!inside(pos, F)) die;
            pos -= normalize(∇F(pos)) * F(pos)/|∇F(pos)|;
            if (!inside(pos, F)) die;
            pos -= normalize(∇F(pos)) * F(pos)/|∇F(pos)|;
            if (!inside(pos, F)) die;
            real energy = 0;
            foreach (particle P in sphere(radius)) {
               energy += phi(|pos - P.pos|/radius);
            }
            if (energy - energyLast > -0.5*(pos - posLast)•force) {
               tt *= 0.5; // backtrack
               pos = posLast;
            } else {
               tt = min(tt*1.5, radius/2); // bigger step on next iter
            }
         }
      }
   }
}

global{
   if (iter == iterLimit) {
      real numFoundIso = sum{ 1 if P.foundIso else 0 | P in particle.all };
      real number = sum{ 1.0 | P in particle.all };
      real phiSum = sum{ P.energyReport | P in particle.all };
      print("stopping at iter ", iter, ": ", numFoundIso, "/", number, "=", numFoundIso/number, " foundIso\n");
      print("   mean phi = ", phiSum/number, "\n");
      stabilize;
   }
   iter+=1;
}

initially { particle(idx0 + sz0*idx1, orig + idx0*dir0 + idx1*dir1)
           | idx1 in 0..(sz1-1),   // SLOWER axis
             idx0 in 0..(sz0-1) }; // FASTER axis
